#!/usr/bin/env python3

# Normalizes CSV data according to specified rules:
# - Converts timestamps from US/Pacific to RFC3339 in US/Eastern
# - Normalizes ZIP codes to 5 digits
# - Converts names to uppercase
# - Converts durations from HH:MM:SS.MS to total seconds
# - Calculates TotalDuration as the sum of FooDuration and BarDuration

import csv
import sys
import io
from datetime import datetime
from zoneinfo import ZoneInfo

def parse_timestamp(timestamp_str):
    """Convert timestamp from US/Pacific to RFC3339 in US/Eastern"""
    if not timestamp_str or not timestamp_str.strip():
        return timestamp_str
    try:
        # TODO: handle multiple input formats
        parsed_dt = datetime.strptime(timestamp_str, '%m/%d/%y %I:%M:%S %p')
        pacific_dt = parsed_dt.astimezone(ZoneInfo("US/Pacific"))
        eastern_dt = pacific_dt.astimezone(ZoneInfo("US/Eastern"))
        return str(eastern_dt.isoformat())
    
    except Exception as e:
        raise ValueError(f"Error parsing timestamp '{timestamp_str}': {e}")
    
def normalize_zip(zip_code):
    """Normalize ZIP code to 5 digits"""
    if not zip_code or not zip_code.strip():
        return zip_code
    
    zip_code = zip_code.strip()
    if len(zip_code) < 5:
        zip_code = zip_code.zfill(5)
    elif len(zip_code) > 5:
        zip_code = zip_code[:5]
    
    return zip_code

def duration_to_seconds(duration_str):
    """Convert HH:MM:SS.MS format to total seconds"""
    if not duration_str or not duration_str.strip():
        return "0"
    try:
        h, m, s = duration_str.split(':')
        total_seconds = int(h) * 3600 + int(m) * 60 + float(s)
        return str(total_seconds)
    
    except Exception as e:
        raise ValueError(f"Error parsing duration '{duration_str}': {e}")

def normalize_row(row):
    """Normalize a single CSV row"""
    normalized = {}
    
    # TODO: handle field names dynamically
    for key, value in row.items():
        if key == 'Timestamp':
            normalized[key] = parse_timestamp(value)
        elif key == 'ZIP':
            normalized[key] = normalize_zip(value)
        elif key == 'FullName':
            normalized[key] = value.upper()
        elif key in ['FooDuration', 'BarDuration']:
            normalized[key] = duration_to_seconds(value)
        elif key == 'TotalDuration':
            foo_duration = float(normalized.get('FooDuration', '0'))
            bar_duration = float(normalized.get('BarDuration', '0'))
            total_duration = foo_duration + bar_duration
            normalized[key] = str(total_duration)
        else:
            normalized[key] = value  # Pass through other columns unchanged

    return normalized

def main():
    try:
        # read from stdin and encode as utf-8 with replacement for invalid chars
        input_stream = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8', errors='replace')
        reader = csv.DictReader(input_stream)
        
        # fieldnames for output CSV, used as keys in DictReader/Writer
        fieldnames = reader.fieldnames
        if not fieldnames:
            raise ValueError("No CSV headers found")
        
        writer = csv.DictWriter(sys.stdout, fieldnames=fieldnames)
        writer.writeheader()

        row_num = 1
        for row in reader:
            row_num += 1
            try:
                normalized_row = normalize_row(row)
                writer.writerow(normalized_row)
            except Exception as e:
                sys.stderr.write(f"Warning: Dropping row {row_num} due to error: {e}\n")
                continue

    except Exception as e:
        sys.stderr.write(f"Error processing CSV: {e}\n")
        sys.exit(1)

if __name__ == '__main__':
    main()